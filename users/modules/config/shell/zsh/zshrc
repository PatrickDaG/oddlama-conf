autoload -U add-zle-hook-widget

# --------------------------------------------------------------------------------
# Keybinds

# Reset all keybinds and use "emacs" keybinds
bindkey
bindkey -d
bindkey -e

function str_to_hex() {
	local str="$1"
	for (( i=0; i<${#str}; i++ )); do
		printf "%02x" "'${str:$i:1}"
	done
}
function atuin-beginning-search-any-end() {
	local reset_offset_to=$_atuin_search_offset
    if [[ -v _atuin_search_last_buffer ]] && [[ "$_atuin_search_last_buffer" == "$BUFFER" ]]; then
		_atuin_search_offset=$((_atuin_search_offset + $direction))
    else
		# You cannot start searching "forward", so instead we wan't to do nothing.
		[[ "$direction" == "-1" ]] && return 1

		reset_offset_to=0
		_atuin_search_offset=0
		_atuin_search_prefix=$LBUFFER
        _atuin_search_original_cursor=$CURSOR
		_atuin_search_original_buffer=$BUFFER
    fi

	# If the offset would become than zero we want to stop searching and reset the buffer,
	# since we essentiall pressed "down" past the first search
    if [[ "$_atuin_search_offset" -ge 0 ]] && zle atuin-prefix-search; then
        zle .end-of-line
		_atuin_search_last_buffer=$BUFFER
    else
		_atuin_search_offset=$reset_offset_to
		# Reset to original input line if the history lookup fails
		# while completing in "forward" direction (ArrowDown) i.e. the offset is 0
		if [[ $_atuin_search_offset == 0 ]]; then
			BUFFER=$_atuin_search_original_buffer
			CURSOR=$_atuin_search_original_cursor
		fi
        return 1
    fi
}; zle -N atuin-beginning-search-any-end

function atuin-reset-search() {
	unset _atuin_search_last_buffer
}; zle -N atuin-beginning-search-any-end
add-zle-hook-widget line-init atuin-reset-search

function atuin-beginning-search-backward-end() {
	direction="1" atuin-beginning-search-any-end
}; zle -N atuin-beginning-search-backward-end
_zsh_autosuggest_bind_widget atuin-beginning-search-backward-end clear

function atuin-beginning-search-forward-end() {
	direction="-1" atuin-beginning-search-any-end
}; zle -N atuin-beginning-search-forward-end
_zsh_autosuggest_bind_widget atuin-beginning-search-forward-end clear

function nop() {
    true
}; zle -N nop

function bindkeys() {
	[[ "$#" -eq 2 ]] || return
	local keys="$1"
	local key
	for key in ${(P)keys}; do
		bindkey "$key" "$2"
	done
}

function setup_keybinds() {
    local keys_Home=(           "${terminfo[khome]}" '\eOH' '\e[H' )
    local keys_End=(            "${terminfo[kend]}"  '\eOF' '\e[F' )
    local keys_Insert=(         "${terminfo[kich1]}" '\e[2~' )

    local keys_Tab=(            "${terminfo[ht]}"    '\t' )
    local keys_ShiftTab=(       "${terminfo[kcbt]}"  '\eOZ' '\e[Z' )

    local keys_Backspace=(      "${terminfo[kbs]}"   '^?')
    local keys_CtrlBackspace=(  "${terminfo[cub1]}"  '^H')
    local keys_AltBackspace=(   '\e^?')

    local keys_Delete=(         "${terminfo[kdch1]}" '\e[3~' )
    local keys_ShiftDelete=(    "${terminfo[kDC]}"   '\e[3;2~' )
    local keys_CtrlDelete=(     '\e[3;5~'            )
    local keys_AltDelete=(      '\e[3;3~'            )

    local keys_Up=(             "${terminfo[kcuu1]}" '\eOA' '\e[A' )
    local keys_ShiftUp=(        "${terminfo[kri]}"  '\e[1;2A' )
    local keys_CtrlUp=(         '\e[1;5A'            )
    local keys_AltUp=(          '\e[1;3A'            )

    local keys_Down=(           "${terminfo[kcud1]}" '\eOB' '\e[B' )
    local keys_ShiftDown=(      "${terminfo[kind]}"  '\e[1;2B' )
    local keys_CtrlDown=(       '\e[1;5B'            )
    local keys_AltDown=(        '\e[1;3B'            )

    local keys_Right=(          "${terminfo[kcuf1]}" '\eOC' '\e[C' )
    local keys_ShiftRight=(     "${terminfo[kRIT]}"  '\e[1;2C' )
    local keys_CtrlRight=(      '\e[1;5C'            )
    local keys_AltRight=(       '\e[1;3C'            )

    local keys_Left=(           "${terminfo[kcub1]}" '\eOD' '\e[D' )
    local keys_ShiftLeft=(      "${terminfo[kLFT]}"  '\e[1;2D'  )
    local keys_CtrlLeft=(       '\e[1;5D'            )
    local keys_AltLeft=(        '\e[1;3D'            )

    local keys_PageUp=(         "${terminfo[kpp]}"   '\e[5~' )
    local keys_ShiftPageUp=(    "${terminfo[kPRV]}"  '\e[5;2~' )

    local keys_PageDown=(       "${terminfo[knp]}"   '\e[6~' )
    local keys_ShiftPageDown=(  "${terminfo[kNXT]}"  '\e[6;2~' )

    bindkeys keys_Home            beginning-of-line
    bindkeys keys_End             end-of-line
    bindkeys keys_Insert          nop

    bindkeys keys_Tab             fzf-tab-complete
    bindkeys keys_ShiftTab        nop

    bindkeys keys_Backspace       backward-delete-char
    bindkeys keys_AltBackspace    backward-kill-word
    bindkeys keys_CtrlBackspace   backward-kill-line

    bindkeys keys_Delete          delete-char
    bindkeys keys_ShiftDelete     delete-word
    bindkeys keys_CtrlDelete      kill-line
    bindkeys keys_AltDelete       delete-word

    bindkeys keys_Up              atuin-beginning-search-backward-end
    bindkeys keys_ShiftUp         up-line
    bindkeys keys_CtrlUp          nop
    bindkeys keys_AltUp           nop

    bindkeys keys_Down            atuin-beginning-search-forward-end
    bindkeys keys_ShiftDown       down-line
    bindkeys keys_CtrlDown        nop
    bindkeys keys_AltDown         nop

    bindkeys keys_Right           forward-char
    bindkeys keys_ShiftRight      forward-word
    bindkeys keys_CtrlRight       nop
    bindkeys keys_AltRight        nop

    bindkeys keys_Left            backward-char
    bindkeys keys_ShiftLeft       backward-word
    bindkeys keys_CtrlLeft        nop
    bindkeys keys_AltLeft         nop

    bindkeys keys_PageUp          nop
    bindkeys keys_ShiftPageUp     nop

    bindkeys keys_PageDown        nop
    bindkeys keys_ShiftPageDown   nop

    # atuin
    bindkey '^R' _atuin_search_widget

    # fzf file and directory related expansions and functions
    bindkey '\ef' fzf-select-file-or-dir
    bindkey '\eF' fzf-select-file-or-dir-hidden
    bindkey '\ed' fzf-select-dir
    bindkey '\eD' fzf-select-dir-hidden
    bindkey '\ec' fzf-cd

	# autosuggest Ctrl+space = accept
	bindkey '^ ' autosuggest-accept
}
setup_keybinds
unfunction setup_keybinds
unfunction bindkeys


# --------------------------------------------------------------------------------
# Completion

# disable sort when completing `git checkout`
zstyle ':completion:*:git-checkout:*' sort false
# set descriptions format to enable group support
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# preview directory's content when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'ls -lAhF --group-directories-first --show-control-chars --quoting-style=escape --color=always $realpath'
zstyle ':fzf-tab:complete:cd:*' popup-pad 20 0


# No correction
zstyle ':completion:*' completer _oldlist _expand _complete _files _ignored

# Don't insert tabs when there is no completion (e.g. beginning of line)
zstyle ':completion:*' insert-tab false

# allow one error for every three characters typed in approximate completer
zstyle ':completion:*:approximate:'    max-errors 'reply=( $((($#PREFIX+$#SUFFIX)/3 )) numeric )'

# start menu completion only if it could find no unambiguous initial string
zstyle ':completion:*:correct:*'       insert-unambiguous true
zstyle ':completion:*:corrections'     format $'%{\e[0;31m%}%d (errors: %e)%{\e[0m%}'
zstyle ':completion:*:correct:*'       original true

# List directory completions first
zstyle ':completion:*' list-dirs-first true
# Offer the original completion when using expanding / approximate completions
zstyle ':completion:*' original true
# Treat multiple slashes as a single / like UNIX does (instead of as /*/)
zstyle ':completion:*' squeeze-slashes true

# insert all expansions for expand completer
# # ???????????????ßß
zstyle ':completion:*:expand:*'        tag-order all-expansions

# match uppercase from lowercase
zstyle ':completion:*'                 matcher-list 'm:{a-z}={A-Z}'

# separate matches into groups
zstyle ':completion:*:matches'         group 'yes'
zstyle ':completion:*'                 group-name ''

zstyle ':completion:*:messages'        format '%d'
zstyle ':completion:*:options'         auto-description '%d'

# describe options in full
zstyle ':completion:*:options'         description 'yes'

# on processes completion complete all user processes
zstyle ':completion:*:processes'       command 'ps -au$USER'

# provide verbose completion information
zstyle ':completion:*'                 verbose true

# Ignore completion functions for commands you don't have:
zstyle ':completion::(^approximate*):*:functions' ignored-patterns '_*'

# Provide more processes in completion of programs like killall:
zstyle ':completion:*:processes-names' command 'ps c -u ${USER} -o command | uniq'

# complete manual by their section
zstyle ':completion:*:manuals'    separate-sections true
zstyle ':completion:*:manuals.*'  insert-sections   true
zstyle ':completion:*:man:*'      menu yes select

# provide .. as a completion
zstyle ':completion:*' special-dirs ..


# --------------------------------------------------------------------------------
# ZSH Options

# Emit an error when a glob has no match
setopt nomatch
# Don't use extended globbing
setopt noextendedglob
# * shouldn't match dotfiles. ever.
setopt noglobdots
# Whenever a command completion is attempted, make sure the entire
# command path is hashed first.
setopt hash_list_all

# Change directory by typing the directory name
setopt auto_cd
# Automatically pushd on cd to have a directory stack
setopt auto_pushd
# Don't push the same dir twice
setopt pushd_ignore_dups
# Display PID when suspending processes as well
setopt long_list_jobs
# Don't send SIGHUP to background processes when the shell exits
setopt nohup
# Report the status of background jobs immediately
setopt notify
# Allow comments in interactive shells
setopt interactive_comments
# Don't beep
setopt nobeep

# Don't try to correct inputs
setopt nocorrect
# Allow in-word completion
setopt complete_in_word
# Don't autocorrect commands
setopt no_correct_all
# List choices on ambiguous completions
setopt auto_list
# Use menu completion if requested explicitly
setopt auto_menu
# Move cursor to end of word if there was only one match
setopt always_to_end

# Ignore certain commands in history
HISTORY_IGNORE_REGEX='^(.|. |..|.. |rm .*|rmd .*|git fixup.*|git unstash|git stash.*|git checkout -f.*)$'
function zshaddhistory() {
	emulate -L zsh
	[[ ! $1 =~ "$HISTORY_IGNORE_REGEX" ]]
}
